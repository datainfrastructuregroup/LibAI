interface UnknownFieldsObject {
    groups?: NodeObject[];
    [key: string]: NodeObject[] | RangeArray[] | NodeArray[] | Array<NodeArray | string> | NameDictObject[] | string | undefined;
}
interface MarkObject {
    type: string;
}
interface OtherNodeObject {
    type: string;
    marks?: MarkObject[];
    attrs?: Record<string, unknown>;
}
interface TextNodeObject {
    type: "text";
    text: string;
    marks?: MarkObject[];
    attrs?: Record<string, unknown>;
}
type NodeObject = OtherNodeObject | TextNodeObject;
type NodeArray = NodeObject[];
interface EntryLocation {
    start: number;
    end: number;
}
interface EntryObject {
    entry_key: string;
    incomplete?: boolean;
    bib_type: string;
    location?: EntryLocation;
    raw_text?: string;
    fields: Record<string, unknown>;
    unexpected_fields?: Record<string, unknown>;
    unknown_fields?: UnknownFieldsObject;
}
type NameDictObject = {
    literal?: NodeArray;
    family?: NodeArray;
    given?: NodeArray;
    prefix?: NodeArray;
    suffix?: NodeArray;
    useprefix?: boolean;
};
type GroupObject = {
    name: string;
    references: string[];
    groups: GroupObject[];
};
type RangeArray = [NodeArray, NodeArray] | [NodeArray];
interface LangidOptions {
    [key: string]: {
        csl: string;
        biblatex: string;
    };
}
interface BibFieldType {
    type: string;
    biblatex: string;
    csl?: string | Record<string, string>;
    options?: string[] | LangidOptions;
    strict?: boolean;
}
/** A list of field types of Bibligraphy DB with lookup by field name. */
declare const BibFieldTypes: Record<string, BibFieldType>;
interface BibType {
    order: number;
    biblatex: string;
    csl: string;
    required: string[];
    eitheror: string[];
    optional: string[];
    "biblatex-subtype"?: string;
}
/** A list of all bib types and their fields. */
declare const BibTypes: Record<string, BibType>;

interface TypeInheritance {
    source: string[];
    target: string[];
    fields: FieldInheritance[];
}
interface FieldInheritance {
    source: string;
    target: string;
}

type StringStartTuplet = [string, () => void];
type WarningObject$1 = {
    type: string;
    group_type: string;
};
declare class GroupParser {
    groups: GroupObject[];
    groupType: string;
    warnings: WarningObject$1[];
    entries: EntryObject[];
    stringStarts: StringStartTuplet[];
    pos: number;
    fileDirectory: string;
    input: string;
    constructor(entries: EntryObject[]);
    checkString(input: string): void;
    readGroupInfo(groupType: string): void;
    readFileDirectory(): void;
    readJabref3(): void;
    clearGroups(groups: GroupObject[]): void;
    readJabref4(): void;
    find(name: string, groups: GroupObject[] | void): GroupObject | false;
}

/** Parses files in BibTeX/BibLaTeX format
 */
interface ConfigObject$2 {
    /**
     * - processUnknown (object [specifying content type for specific unknown]):
     *
     * Processes fields with names that are unknown, adding them to an `unknown_fields`
     * object to each entry.
     *
     * example:
     *   > a = new BibLatexParser(..., {processUnknown: true})
     *   > a.output
     *   {
     *       "0:": {
     *           ...
     *           unknown_fields: {
     *               ...
     *           }
     *       }
     *   }
     *
     *   > a = new BibLatexParser(..., {processUnknown: {commentator: 'l_name'}})
     *   > a.output
     *   {
     *       "0:": {
     *           ...
     *           unknown_fields: {
     *               commentator: [
     *                   {
     *                       given: ...,
     *                       family: ...
     *                   }
     *               ]
     *               ...
     *           }
     *       }
     *   }
     */
    processUnknown?: boolean | Record<string, string>;
    /**
     * Processes fields with names that are known, but are not expected for the given bibtype,
     * adding them to an `unexpected_fields` object to each entry.
     */
    processUnexpected?: boolean;
    processInvalidURIs?: boolean;
    processComments?: boolean;
    /**
     * Include source location to an `location` object on each entry
     *
     * example:
     *   > a = new BibLatexParser(..., {includeLocation: true})
     *   > a.output
     *   {
     *       "0:": {
     *           ...
     *           location: {
     *               start: 1,
     *               end: 42
     *           }
     *       }
     *   }
     */
    includeLocation?: boolean;
    /**
     * Include source text to an `raw_text` property on each entry
     *
     * example:
     *   > a = new BibLatexParser(..., {includeRawText: true})
     *   > a.output
     *   {
     *       "0:": {
     *           ...
     *           raw_text: '@article{...}'
     *       }
     *   }
     */
    includeRawText?: boolean;
    crossRefInheritance?: TypeInheritance[];
    includeUnusedNocase?: boolean;
}
interface ErrorObject$1 {
    type: string;
    expected?: string;
    found?: string;
    line?: number;
    key?: string;
    entry?: string;
    field?: string;
    field_name?: string;
    alias_of?: string;
    alias_of_value?: unknown;
    value?: string[] | string;
    variable?: string;
    type_name?: string;
}
interface MatchOptionsObject {
    skipWhitespace: string | boolean;
}
interface BiblatexParseResult {
    entries: {
        [key: number]: EntryObject;
    };
    errors: ErrorObject$1[];
    warnings: ErrorObject$1[];
    comments: string[];
    strings: Record<string, string>;
    jabref: {
        groups: GroupObject[] | false;
        meta: Record<string, string>;
    };
}
interface BibDB {
    [key: number]: EntryObject;
}
declare class BibLatexParser {
    input: string;
    config: ConfigObject$2;
    pos: number;
    startPosition: number;
    endPosition: number;
    entries: EntryObject[];
    currentKey: string | false;
    currentEntry?: EntryObject;
    currentType: string;
    currentRawFields?: Record<string, unknown>;
    bibDB: BibDB;
    errors: ErrorObject$1[];
    warnings: ErrorObject$1[];
    months: {
        JAN: string;
        FEB: string;
        MAR: string;
        APR: string;
        MAY: string;
        JUN: string;
        JUL: string;
        AUG: string;
        SEP: string;
        OCT: string;
        NOV: string;
        DEC: string;
    };
    strings: Record<string, string>;
    comments: string[];
    groupParser: GroupParser;
    groups: GroupObject[] | false;
    jabrefMeta: Record<string, string>;
    jabref?: {
        groups: GroupObject[] | false;
        meta: number;
    };
    crossrefs: Record<string, string>;
    constructor(input: string, config?: ConfigObject$2);
    isWhitespace(s: string): boolean;
    error(data: ErrorObject$1): void;
    warning(data: ErrorObject$1): void;
    match(s: string, options?: MatchOptionsObject): void;
    tryMatch(s: string): boolean;
    skipWhitespace(): void;
    skipToNext(): boolean;
    valueBraces(): string;
    valueQuotes(): string;
    singleValue(): string;
    value(asis?: boolean): string;
    key(optional?: boolean): string;
    keyEqualsValue(asis?: boolean): [string, string] | false;
    keyValueList(): void;
    processFields(): void;
    _reformKey(keyString: string, fKey: string): string | NodeArray;
    _checkURI(uriString: string): boolean;
    _reformURI(uriString: string): string;
    _reformNameList(nameString: string): NameDictObject[];
    _reformRange(rangeString: string): RangeArray[];
    _reformLiteral(theValue: string, cpMode?: boolean): NodeArray;
    bibType(): string;
    createNewEntry(): void;
    directive(): string | null;
    string(): void;
    preamble(): void;
    replaceTeXChars(): void;
    stepThroughBibtex(): void;
    stepThroughBibtexAsync(): Promise<null>;
    parseNext(): void;
    parseComment(braceless: boolean): void;
    createBibDB(): void;
    cleanDB(): void;
    get output(): BibDB;
    _resolveCrossRef(key: string, parentKey: string): void;
    _resoveAllCrossRefs(): void;
    parsed(): BiblatexParseResult;
    parse(): BiblatexParseResult;
    parseAsync(): Promise<BiblatexParseResult>;
}
declare function parse(input: string, config?: ConfigObject$2): BiblatexParseResult;
declare function parseAsync(input: string, config?: ConfigObject$2): Promise<BiblatexParseResult>;

type ConfigObject$1 = {
    traditionalNames?: boolean;
    exportUnexpectedFields?: boolean;
};
type BibObject = {
    type: string;
    key: string;
    values?: Record<string, unknown>;
};
type WarningObject = {
    type: string;
    variable: string;
};
declare class BibLatexExporter {
    bibDB: BibDB;
    pks: string[];
    config: ConfigObject$1;
    warnings: WarningObject[];
    bibtexStr: string;
    bibtexArray: BibObject[];
    constructor(bibDB: BibDB, pks?: string[] | false, config?: ConfigObject$1);
    get output(): string;
    parse(): string;
    _reformKey(theValue: string | unknown, fKey: string): string;
    _reformRange(theValue: unknown): string;
    _reformInterval(theValue: unknown): string;
    _reformName(theValue: unknown): string;
    _protectNamePart(namePart: string): string;
    _escapeTeX(theValue: unknown): string;
    _reformText(theValue: unknown): string;
    _getBibtexString(biblist: BibObject[]): string;
}

type ConfigObject = {
    escapeText?: boolean;
};
type ErrorObject = {
    type: string;
    variable: string;
};
type CSLDateObject = {
    "date-parts"?: [number[]] | [number[], number[]];
    circa?: boolean;
};
type CSLNameObject = {
    literal?: string;
    given?: string;
    family?: string;
    suffix?: string;
    "non-dropping-particle"?: string;
    "dropping-particle"?: string;
};
interface CSLEntry {
    id?: string;
    [key: string]: unknown;
}
type CSLOutput = Record<string, CSLEntry>;
declare class CSLExporter {
    bibDB: BibDB;
    pks: string[];
    config: ConfigObject;
    cslDB: Record<string, CSLEntry>;
    errors: ErrorObject[];
    constructor(bibDB: BibDB, pks?: string[] | false, config?: ConfigObject);
    get output(): CSLOutput;
    parse(): CSLOutput;
    /** Converts one BibDB entry to CSL format.
     * @function getCSLEntry
     * @param id The id identifying the bibliography entry.
     */
    getCSLEntry(id: string): CSLEntry;
    _reformThesisType(theValue: string): string;
    _reformKey(theValue: string | unknown, fKey: string): string;
    _reformRange(theValue: unknown): string;
    _reformInterval(theValue: unknown): string;
    _reformInteger(theValue: unknown): string | number;
    _escapeText(theValue: unknown): string;
    _reformTitle(theValue: unknown): string;
    _reformText(theValue: unknown): string;
    _reformDate(dateStr: string): false | CSLDateObject;
    _reformName(theNames: NameDictObject[]): CSLNameObject[];
}

type SimpleDateArray = Array<string | number>;
type DateArray = readonly (string | number | SimpleDateArray)[];
interface EDTFOutputObject {
    type: string;
    valid: boolean;
    values: DateArray;
    cleanedString: string;
    uncertain: boolean;
    approximate: boolean;
}
declare function edtfParse(dateString: string): EDTFOutputObject;

declare function unescapeCSL(theValue: string): string;

export { BibDB, BibFieldTypes, BibLatexExporter, BibLatexParser, BibTypes, BiblatexParseResult, CSLEntry, CSLExporter, CSLOutput, edtfParse, parse, parseAsync, unescapeCSL };
